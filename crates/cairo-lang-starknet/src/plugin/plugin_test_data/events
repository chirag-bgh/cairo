//! > Test expansion of a simple starknet contract.

//! > test_runner_name
ExpandContractTestRunner

//! > cairo_code
#[derive(Drop, starknet::Event)]
struct MyEventStruct {
    x: felt252,
    data: Array::<felt252>,
}

#[derive(starknet::Event)]
enum MyEventEnum {
    #[event]
    A: MyEventStruct,
    B: felt252,
}

//! > generated_cairo_code
lib.cairo:

#[derive(Drop, starknet::Event)]
struct MyEventStruct {
    x: felt252,
    data: Array::<felt252>,
}

#[derive(starknet::Event)]
enum MyEventEnum {
    #[event]
    A: MyEventStruct,
    B: felt252,
}

impls:

impl MyEventStructDrop<> of Drop::<MyEventStruct<>>;


event_impl:

impl MyEventStructIsEvent of starknet::Event<MyEventStruct> {
    fn append_keys_and_values(
        self: @MyEventStruct, ref keys: Array<felt252>, ref values: Array<felt252>
    ) {
                serde::Serde::serialize(self.x, ref values);
                serde::Serde::serialize(self.data, ref values);
    }
    fn deserialize(
        ref keys: Span<felt252>, ref values: Span<felt252>,
    ) -> Option<MyEventStruct> {
                let x = serde::Serde::deserialize(
                    ref values
                )?;
                let data = serde::Serde::deserialize(
                    ref values
                )?;
        Option::Some(MyEventStruct {x, data, })
    }
}

event_impl:

impl MyEventEnumIsEvent of starknet::Event<MyEventEnum> {
    fn append_keys_and_values(
        self: @MyEventEnum, ref keys: Array<felt252>, ref values: Array<felt252>
    ) {
        match self {
            MyEventEnum::A(val) => {
                array::ArrayTrait::append(ref keys, 0x3783fac2efed8fbc9ad443e592ee30e61d65f471140c10ca155e937b435b760);
                starknet::Event::append_keys_and_values(
                    val, ref keys, ref values
                );
            },
            MyEventEnum::B(val) => {
                array::ArrayTrait::append(ref keys, 0x3675bff07515f5df96737194ea945c36c41e7b4fcef307b7cd4d0e602a69111);
                serde::Serde::serialize(val, ref values);
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref values: Span<felt252>,
    ) -> Option<MyEventEnum> {
        let selector = *array::SpanTrait::pop_front(ref keys)?;
        
            if selector == 0x3783fac2efed8fbc9ad443e592ee30e61d65f471140c10ca155e937b435b760 {
                let val = starknet::Event::deserialize(
                    ref keys, ref values
                )?;
                return Option::Some(MyEventEnum::A(val));
            }
            if selector == 0x3675bff07515f5df96737194ea945c36c41e7b4fcef307b7cd4d0e602a69111 {
                let val = serde::Serde::deserialize(
                    ref values
                )?;
                return Option::Some(MyEventEnum::B(val));
            }
        Option::None(())
    }
}

//! > expected_diagnostics
error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> lib.cairo:26:34
        Option::Some(*serialized.pop_front()? != 0)
                                 ^*******^

error: Desnap operator can only be applied on snapshots
 --> lib.cairo:26:22
        Option::Some(*serialized.pop_front()? != 0)
                     ^

error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> lib.cairo:103:34
        Option::Some(*serialized.pop_front()?)
                                 ^*******^

error: Desnap operator can only be applied on snapshots
 --> lib.cairo:103:22
        Option::Some(*serialized.pop_front()?)
                     ^

error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> option.cairo:20:35
        let variant = *serialized.pop_front()?;
                                  ^*******^

error: Desnap operator can only be applied on snapshots
 --> option.cairo:20:23
        let variant = *serialized.pop_front()?;
                      ^

error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> integer.cairo:21:36
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                   ^*******^

error: Desnap operator can only be applied on snapshots
 --> integer.cairo:21:24
        Option::Some(((*serialized.pop_front()?).try_into())?)
                       ^

error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> integer.cairo:288:36
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                   ^*******^

error: Desnap operator can only be applied on snapshots
 --> integer.cairo:288:24
        Option::Some(((*serialized.pop_front()?).try_into())?)
                       ^

error: Trait `core::traits::TryInto::<<missing>, core::integer::u8>` has multiple implementations, in: "core::integer::U32TryIntoU8", "core::integer::Felt252TryIntoU8", "core::integer::U16TryIntoU8", "core::integer::U128TryIntoU8", "core::integer::U64TryIntoU8"
 --> integer.cairo:288:50
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                                 ^******^

error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> integer.cairo:463:36
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                   ^*******^

error: Desnap operator can only be applied on snapshots
 --> integer.cairo:463:24
        Option::Some(((*serialized.pop_front()?).try_into())?)
                       ^

error: Trait `core::traits::TryInto::<<missing>, core::integer::u16>` has multiple implementations, in: "core::integer::U128TryIntoU16", "core::integer::U64TryIntoU16", "core::integer::U32TryIntoU16", "core::integer::Felt252TryIntoU16"
 --> integer.cairo:463:50
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                                 ^******^

error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> integer.cairo:639:36
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                   ^*******^

error: Desnap operator can only be applied on snapshots
 --> integer.cairo:639:24
        Option::Some(((*serialized.pop_front()?).try_into())?)
                       ^

error: Trait `core::traits::TryInto::<<missing>, core::integer::u32>` has multiple implementations, in: "core::integer::U64TryIntoU32", "core::integer::Felt252TryIntoU32", "core::integer::U128TryIntoU32"
 --> integer.cairo:639:50
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                                 ^******^

error: Method `pop_front` not found on type "core::array::Span::<core::felt252>". Did you import the correct trait and impl?
 --> integer.cairo:815:36
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                   ^*******^

error: Desnap operator can only be applied on snapshots
 --> integer.cairo:815:24
        Option::Some(((*serialized.pop_front()?).try_into())?)
                       ^

error: Trait `core::traits::TryInto::<<missing>, core::integer::u64>` has multiple implementations, in: "core::integer::Felt252TryIntoU64", "core::integer::U128TryIntoU64"
 --> integer.cairo:815:50
        Option::Some(((*serialized.pop_front()?).try_into())?)
                                                 ^******^
